---
title: "Visual Studio 2015 Visual C++의 새로운 기능 | Microsoft Docs"
ms.custom: ""
ms.date: "12/16/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 1cc09fad-85a2-43c2-b022-bb99f5fe0ad7
caps.latest.revision: 101
caps.handback.revision: 101
author: "ghogen"
ms.author: "ghogen"
manager: "ghogen"
---
# Visual Studio 2015 Visual C++의 새로운 기능
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Visual Studio 2015에서 C\+\+ 컴파일러 및 표준 라이브러리는 C\+\+11에 대한 향상된 지원 기능과 특정 C\+\+14 기능에 대한 초기 지원 기능으로 업데이트되었습니다.  또한 C\+\+17 표준에 포함될 것으로 예상되는 특정 기능에 대한 예비 지원 기능도 포함하고 있습니다.  
  
 이 밖에도 [Android 및 iOS](../Topic/Visual%20C++%20for%20Cross-Platform%20Mobile%20Development.md)에서 플랫폼 간 다중 장치 개발을 위한 프로젝트 템플릿도 추가되었고 다양한 [진단](#BK_Diagnostics) 및 [생산성](#BK_IDE) 기능이 향상되었으며 [빌드 시간](#BK_FasterBuildTimes)이 상당히 개선되었습니다.  
  
> [!WARNING]
>  Visual Studio 2015에서는 Visual C\+\+가 기본적으로 설치되어 있지 않습니다.  설치할 때 **사용자 지정** 설치를 선택한 후 필요한 C\+\+ 구성 요소를 선택해야 합니다.  Visual Studio가 이미 설치되어 있는 경우 **파일 &#124; 새로 만들기 &#124; 프로젝트 &#124; C\+\+**를 선택합니다. 그러면 필요한 구성 요소를 설치하라는 메시지가 표시됩니다.  
  
 Visual Studio 2015에서 추가된 다른 기능에 대한 자세한 내용은 [Visual Studio 2015의 새로운 기능](../Topic/What's%20New%20in%20Visual%20Studio%202015.md)을 참조하세요.  
  
 항목 내용:  
  
1.  [컴파일러](#BK_Compiler)  
  
2.  [C++ 표준 라이브러리](#BK_CppStdLib)  
  
3.  [C 런타임 라이브러리](#BK_CRT)  
  
4.  [빌드 시간 단축](#BK_FasterBuildTimes)  
  
5.  [성능 및 코드 품질](#BK_PerfCodeQuality)  
  
6.  [생산성, 디버깅 및 진단](#BK_IDE)  
  
    1.  [단일 파일 IntelliSense](#BK_SingleFileIntelliSense)  
  
    2.  [리팩터링](#BK_Refactoring)  
  
    3.  [프로그램 데이터베이스 향상 기능](#BK_PDB)  
  
    4.  [진단](#BK_Diagnostics)  
  
7.  [Windows 10 대상](#BK_Win10)  
  
8.  [그래픽 진단](#BK_GraphicsDiagnostics)  
  
9. [새로운 GPU 사용량 도구](#BK_GPUUsage)  
  
10. [MFC의 새로운 기능](#BK_MFC)  
  
## ISO C\/C\+\+ 표준 지원  
  
###  <a name="BK_Compiler"></a> 컴파일러  
  
-   **다시 시작 가능한 함수\(resume\/await\)** resume 및 await 키워드는 비동기 프로그래밍에 대한 언어 수준 지원을 제공하고 다시 시작 가능한 함수를 사용할 수 있게 합니다.  현재 이 기능은 여전히 실험적이며 x64 대상에만 사용할 수 있습니다.  **\(C\+\+17 \[N3858\]에 대해 제안됨\)**  
  
-   **제네릭\(다형\) 람다 식** 이제 auto를 사용하여 람다 함수 매개 변수 형식을 지정할 수 있습니다. 컴파일러는 이 컨텍스트에서 auto를 해석할 때 클로저의 함수 호출 연산자가 멤버 함수 템플릿이고 람다 식에서 각각의 auto 사용은 고유한 템플릿 형식 매개 변수에 해당하는 것으로 인식합니다.  **\(C\+\+14 \)**  
  
-   **일반화된 람다 캡처 식** init\-capture라고도 합니다.  이제 임의의 식에 대한 결과를 람다의 캡처 절에 있는 변수에 할당할 수 있습니다.  이에 따라 이동 전용 형식을 값으로 캡처할 수 있으며 람다 식의 클로저 개체에서 임의의 데이터 멤버를 정의할 수 있습니다.  **\(C\+\+14\)**  
  
-   **이진 리터럴** 이제 이진 리터럴이 지원됩니다.  이러한 리터럴은 0B 또는 0b 접두사가 붙고 숫자 0과 1로만 구성됩니다.  **\(C\+\+14\)**  
  
-   **반환 형식 추론** 이제 일반 함수의 반환 형식을 추론할 수 있습니다. 이러한 함수에는 여러 반환 문이 포함된 함수와 재귀 함수가 포함됩니다.  이러한 함수 정의 앞에는 후행 반환 형식이 포함된 함수 정의에서와 같이 auto 키워드가 오지만 후행 반환 형식은 생략됩니다.  **\(C\+\+14\)**  
  
-   **decltype\(auto\)** 식 초기화에 auto 키워드를 사용하는 형식 추론에서는 ref\-qualifier와 최상위 cv\-qualifier를 식에서 제거합니다.  decltype\(auto\)식 초기화에 auto 키워드를 사용하는 형식 추론에서는 ref\-qualifier와 최상위 cv\-qualifier를 식에서 제거합니다.  **\(C\+\+14\)**  
  
-   **이동 특수 멤버 함수의 암시적 생성** 이제 이동 생성자와 이동 할당 연산자가 조건에 따라 암시적으로 생성되므로 컴파일러가 C\+\+11 rvalue 참조를 완전히 준수합니다.  **\(C\+\+11\)**  
  
-   **생성자 상속** 파생 클래스는 이제 Base::Base;를 사용하는 문을 정의에 포함하여 기본 클래스 Base의 생성자를 상속함을 지정할 수 있습니다.  파생 클래스는 기본 클래스의 모든 생성자만 상속할 수 있으며 특정 기본 생성자만 상속하는 방법은 없습니다.  파생 클래스는 서명이 동일한 생성자가 포함된 여러 기본 클래스에서 상속할 수 없으며 상속된 생성자에 대한 동일한 서명을 가진 생성자를 정의할 수 없습니다.  **\(C\+\+11\)**  
  
-   **맞춤 쿼리 및 제어** 변수의 맞춤은 alignof\(\) 연산자를 사용하여 쿼리되고 alignas\(\) 지정자를 사용하여 제어될 수 있습니다.  alignof\(\)는 형식 인스턴스가 할당되어야 하는 바이트 경계를 반환합니다. 참조의 경우 참조된 형식의 맞춤을 반환하고 배열의 경우 요소 형식의 맞춤을 반환합니다.  alignas\(\)는 변수의 맞춤을 제어합니다. 상수나 형식을 사용하며 형식은 alignas\(alignof\(type\)\)를 줄인 것입니다.  **\(C\+\+11\)**  
  
-   **크기 지정된 할당 해제** 이제 전역  `void operator delete(void *, std::size_t) noexcept` 및 `void operator delete[](void *, std::size_t) noexcept`를 오버로드할 수 있습니다.  
  
-   **확장된 sizeof** 이제 sizeof\(\)를 사용하여 클래스나 구조체의 인스턴스 없이도 클래스 또는 구조체 멤버 변수의 크기를 확인할 수 있습니다. **\(C\+\+11\)**  
  
-   **특성**은 새 키워드를 정의하지 않고 함수, 변수, 형식 및 다른 프로그램 요소의 구문을 확장하는 방법을 제공합니다.**\(C\+\+11\)**  
  
-   **constexpr** 컴파일 타임에 상수 변수, 함수 및 사용자 정의 형식을 만듭니다.  **\(C\+\+11\)**  
  
-   **UDL\(사용자 정의 리터럴\)** 이제 의미 있는 접미사를 숫자 및 문자열 리터럴에 추가하여 특정 의미 체계를 제공할 수 있습니다.  컴파일러는 접미사가 붙은 리터럴을 적절한 UDL 연산자에 대한 호출로 해석합니다.  **\(C\+\+11\)**  
  
-   **스레드로부터 안전한 "매직" 정적 변수** 정적 지역 변수가 이제 스레드로부터 안전한 방식으로 초기화되므로 수동으로 동기화할 필요가 없습니다.  초기화만 스레드로부터 안전하며 여러 스레드의 정적 지역 변수 사용은 여전히 수동으로 동기화되어야 합니다.  CRT에 대한 종속성 사용을 방지하기 위해 \/Zc:threadSafeInit\- 플래그를 사용하여 스레드로부터 안전한 정적 기능을 사용하지 않도록 설정할 수 있습니다.  **\(C\+\+11\)**  
  
-   **스레드 로컬 저장소** thread\_local 키워드를 사용하여 각 스레드에 대해 독립 개체를 만들도록 선언할 수 있습니다.  **\(C\+\+11\)**  
  
-   **noexcept** 이제 noexcept 연산자를 사용하여 식에서 예외를 throw할 수 있는지 여부를 확인할 수 있습니다.  이제 noexcept 지정자를 사용하여 함수에서 예외를 throw하지 않음을 지정할 수 있습니다.  **\(C\+\+11\)**  
  
-   **인라인 네임스페이스** 이제 네임스페이스를 인라인으로 지정하여 해당 내용을 바깥쪽 네임스페이스로 올릴 수 있습니다.  인라인 네임스페이스를 사용하여 기본적으로 최신 버전을 노출하는 버전이 있는 라이브러리를 만드는 한편 이전 API 버전을 여전히 명시적으로 사용 가능하게 만들 수 있습니다.  **\(C\+\+11\)**  
  
-   **제한 없는 공용 구조체** 공용 구조체 형식은 이제 특수한 생성자가 있는 형식을 포함할 수 있습니다.  이러한 공용 구조체의 생성자를 정의해야 합니다.  **\(C\+\+11\)**  
  
-   **새로운 문자 형식 및 유니코드 리터럴** UTF\-8, UTF\-16 및 UTF\-32의 문자 및 문자열 리터럴이 이제 지원되며 새로운 문자 형식 char16\_t 및 char32\_t가 도입되었습니다.  문자 리터럴 앞에는 U'a'와 같이 u8\(UTF\-8\), u\(UTF\-16\) 또는 U\(UTF\-32\)가 올 수 있으며, 문자열 리터럴 앞에는 해당하는 원시 문자열인 u8R\(UTF\-8 원시 문자열\), uR\(UTF\-16 원시 문자열\) 또는 UR\(UTF\-32 원시 문자열\)이 추가로 올 수 있습니다.  유니버설 문자 이름은 u'\\u00EF', u8"\\u00EF is i" 및 u"\\U000000ef is I"와 같이 유니코드 리터럴에 자유롭게 사용할 수 있습니다.  **\(C\+\+11\)**  
  
-   **자릿수 구분 기호** 일정한 간격마다 작은따옴표를 삽입하여 긴 숫자 리터럴을 읽기 쉽게 만들 수 있습니다.  `int x = 1'000'000;` **C\+\+14**  
  
-   **\_\_func\_\_** 미리 정의된 식별자 \_\_func\_\_는 바깥쪽 함수의 정규화되지 않고 표시되지 않은 이름을 포함하는 문자열로 암시적으로 정의됩니다.  
  
-   **\_\_restrict \_\_** 이제 참조에 제한을 적용할 수 있습니다.  
  
###  <a name="BK_CppStdLib"></a> C\+\+ 표준 라이브러리  
  
-   **표준 라이브러리 형식에 대한 UDL\(사용자 정의 리터럴\)** \<chrono\>, \<string\> 및 \<complex\> 헤더는 이제 편의를 위해 UDL 연산자를 제공합니다.  예를 들어 123ms는 std::chrono::milliseconds\(123\)를 의미하고 "hello"s는 std::string\("hello"\)을 의미하며 3.14i는 std::complex\(0.0, 3.14\)를 의미합니다.  
  
-   **Null 정방향 반복기** 이제 표준 라이브러리에서 컨테이너 인스턴스를 참조하지 않는 정방향 반복기를 만들 수 있습니다.  이러한 반복기는 값이 초기화되며 특정 컨테이너 형식에 대해 같은지 비교됩니다.  값이 초기화된 반복기와 값이 초기화되지 않은 반복기의 비교는 정의되어 있지 않습니다.  **\(C\+\+14\)**  
  
-   **quoted\(\)** 이제 표준 라이브러리는 따옴표 붙은 문자열 값 및 I\/O 작업을 더 쉽게 수행할 수 있도록 quoted\(\) 함수를 지원합니다.  quoted\(\)를 사용하면 따옴표 붙은 전체 문자열이 단일 엔터티로 취급됩니다\(공백이 아닌 문자의 문자열이 I\/O 스트림에 있음\). 또한 이스케이프 시퀀스가 I\/O 작업을 통해 보존됩니다.  **\(C\+\+14\)**  
  
-   **유형이 다른 연관 조회** 이제 표준 라이브러리는 연관 컨테이너에 대해 유형이 다른 조회 함수를 지원합니다.  이러한 함수를 사용하면 형식이 key\_type과 비교 가능한 경우 key\_type 이외의 형식으로 조회할 수 있습니다.  **\(C\+\+14\)**  
  
-   **컴파일 타임 정수 시퀀스** 이제 표준 라이브러리는 매개 변수 팩 작업을 더 쉽게 수행하고 특정 템플릿 프로그래밍 패턴을 간소화하기 위해 컴파일 타임에 계산될 수 있는 정수 값의 시퀀스를 나타내는 integer\_sequence 형식을 지원합니다.  **\(C\+\+14\)**  
  
-   **exchange\(\)** 이제 표준 라이브러리는 개체에 새 값을 할당하고 이전 값을 반환하기 위해 std::exchange\(\) 유틸리티 함수를 지원합니다.  복합 형식의 경우 exchange\(\)는 이동 생성자를 사용할 수 있는 경우 이전 값의 복사를 방지하고 이동하거나 임시적인 새 값의 복사를 방지하며 변환하는 할당 연산자를 이용하여 모든 형식을 새 값으로 받아들입니다.  **\(C\+\+14\)**  
  
-   **이중 범위 equal\(\), is\_permutation\(\), mismatch\(\)** 이제 표준 라이브러리는 두 범위를 받아들이는 std::equal\(\), std::is\_permutation\(\) 및 std::mismatch\(\)의 오버로드를 지원합니다.  이러한 오버로드는 두 시퀀스의 길이가 같은지 확인하여 호출 코드에서 이 작업을 수행할 필요성을 없앱니다. 무작위 반복기의 요구 사항을 지원하지 않는 시퀀스의 경우 이러한 오버로드는 요소를 비교하는 동안 길이를 확인하여 효율성을 높입니다.  **\(C\+\+14\)**  
  
-   **get\<T\>\(\)** 이제 표준 라이브러리는 get\<T\>\(\) 템플릿 함수를 지원하여 튜플 요소를 형식에 따라 처리할 수 있도록 합니다.  튜플에 동일한 형식 get\<T\>\(\)의 요소가 둘 이상 포함된 경우 튜플을 해당 형식에 따라 처리할 수 없지만 다른 고유하게 형식화된 요소는 여전히 처리할 수 있습니다.  **\(C\+\+14\)**  
  
-   **tuple\_element\_t** 이제 표준 라이브러리는 tuple\_element\<I, T\>::type 형식 이름의 별칭인 tuple\_element\_t\<I, T\> 형식 별칭을 지원합니다.  이 형식 별칭은 \<type\_traits\>의 다른 메타 함수 형식 별칭과 유사하게 템플릿 프로그래머에게 편의를 제공합니다.  **\(C\+\+14\)**  
  
-   **파일 시스템 "V3" 기술 사양** 포함된 파일 시스템 기술 사양 구현이 버전 3으로 업데이트되었습니다.  \[N3940\]  
  
-   **최소 할당자** 이제 표준 라이브러리는 최소 할당자 인터페이스를 완전히 지원합니다. 주요 수정 사항에는 std::function, shared\_ptr, allocate\_shared\(\) 및 basic\_string이 포함됩니다.  **\(C\+\+11\)**  
  
-   **\<chrono\>** chrono 형식인 high\_resolution\_clock 및 steady\_clock이 수정되었습니다.  **\(C\+\+11\)**  
  
-   **N2761 신호 처리기의 원자성 \(C\+\+11\)**  
  
-   **N3922 중괄호로 묶인 Init 목록을 사용한 auto에 대한 새 규칙 \(C\+\+17\)**  
  
-   **N4051 템플릿 template\-parameters의 typename \(C\+\+17\)**  
  
-   **N4259 std::uncaught\_exceptions\(\)**  
  
-   **N4266 네임스페이스 및 열거자에 대한 특성**  
  
-   **N4267 u8 문자 리터럴**  
  
###  <a name="BK_CRT"></a> C 런타임 라이브러리  
 **CRT 라이브러리 리팩터링**CRT가 두 부분으로 리팩터링되었습니다.  **범용 CRT**에는 표준 C 런타임 라이브러리를 구현하는 코드가 포함되어 있습니다.  vcruntime140.dll\(또는 .lib\)에는 프로세스 시작 및 예외 처리에 대한 버전별 코드가 포함되어 있습니다.  범용 CRT에는 안정적인 API가 있으므로 각 Visual Studio 릴리스에서 버전 번호를 변경하지 않고 사용할 수 있습니다.  이제 Windows 업데이트에서 서비스하는 Windows 운영 체제의 구성 요소입니다.  Windows 10에는 이미 설치되어 있습니다.  Visual C\+\+ 재배포 가능 패키지\(vcredist\)를 사용하여 이전 버전의 Windows에 대한 응용 프로그램과 함께 배포할 수 있습니다.  
  
 **C99 규칙** [!INCLUDE[vs_dev14](../ide/includes/vs_dev14_md.md)] Visual C\+\+ 컴파일러에서 아직 지원하지 않는 컴파일러 기능에 종속된 모든 라이브러리 기능을 제외\(예: \<tgmath.h\>는 구현되지 않음\)하고 C99 표준 라이브러리를 완벽하게 구현합니다.  
  
 **성능** 많은 라이브러리가 리팩터링되어 헤더 파일 매크로 사용법이 간소화되었습니다.  이를 통해 컴파일 및 IntelliSense의 속도가 빨라지고 가독성이 개선됩니다.  또한 많은 stdio 함수가 표준 준수 및 성능 개선을 위해 다시 작성되었습니다.  
  
### 주요 변경 사항  
 이렇게 향상된 ISO C\/C\+\+ 표준 지원 기능을 사용하려면 C\+\+11 및 C99를 따르고 Visual Studio 2015에서 올바르게 컴파일되도록 기존 코드를 변경해야 할 수 있습니다.  자세한 내용은 [Visual C\+\+ 2015의 주요 변경 내용](../porting/visual-cpp-change-history-2003-20151.md)을 참조하세요.  
  
 ppltasks.h의 concurrency::task 클래스와 관련 형식은 더 이상 ConcRT 런타임을 기반으로 하지 않으며  이제 Windows 스레드 풀을 스케줄러로 사용합니다.  이는 concurrency::task 작업 내에서 ConcRT 동기화 기본 형식을 사용하는 코드에만 영향을 미칩니다.  이러한 코드는 Windows 동기화 기본 형식을 대신 사용해야 합니다.  
  
 STL의 동기화 기본 형식도 더 이상 ConcRT를 기반으로 하지 않습니다.  교착 상태를 방지하려면 **concurrency::parallel\_for**와 같은 함수나 PPL 비동기 에이전트 형식이 포함된 함수 내에서 STL 동기화 기본 형식을 사용하지 않아야 합니다.  
  
##  <a name="BK_FasterBuildTimes"></a> 빌드 시간 단축  
  
-   **증분 LTCG\(링크 타임 코드 생성\)** 이제 증분 링크를 LTCG와 함께 사용하여 LTCG를 사용하는 응용 프로그램의 링크 시간을 줄일 수 있습니다.  \/LTCG:incremental 및 \/LTCG:incremental\_rebuild 링커 스위치를 사용하여 이 기능을 활성화합니다.  \\  
  
-   **정적 라이브러리의 증분 링크** 다른 코드 모듈에서 참조하는 정적 라이브러리의 변경 사항이 이제 증분 링크됩니다.  
  
-   **\/Debug:FastLink**는 새로운 PDB 생성 기술을 사용하여 링크 시간을 상당히 줄입니다.  
  
-   링크 시간을 줄이기 위해 링커의 알고리즘이 개선되었습니다.  
  
-   템플릿을 많이 사용하는 코드를 빠르게 빌드할 수 있도록 기능이 개선되었습니다.  
  
-   **빠른 PGO\(프로필 기반 최적화\) 계측** 게임 및 실시간 시스템용의 새로운 경량 계측 모드가 PGO에 도입되었습니다.  \/GENPROFILE 및 \/FASTGETPROFILE 링커 스위치를 통해 제공되는 다른 새 기능을 사용할 수 있을 뿐 아니라 이제는 PGO 사용 시 코드의 품질과 빌드 속도 간의 균형을 적절하게 유지할 수 있습니다.  
  
-   **개체 파일 크기 감소** 컴파일러 및 C\+\+ 표준 라이브러리가 개선되어 개체 파일 및 정적 라이브러리의 크기가 매우 작아졌습니다.  중복 코드는 이전에 링커를 통해 제거되었으므로 이러한 기능 향상은 DLL\(동적 연결 라이브러리\) 또는 실행 파일\(EXE\)의 크기에 영향을 주지 않습니다.  
  
##  <a name="BK_PerfCodeQuality"></a> 성능 및 코드 품질  
  
-   **자동 벡터화 개선** 이제 제어 흐름의 벡터화\(if\-then\-else\) 및 \/O1에서 컴파일할 때의 벡터화\(크기 최소화\) 기능이 포함되었으며 병렬 STL 지원, 더 많은 범위 기반 for 루프 벡터화 및 \#pragma 루프\(ivdep\) 지원을 비롯한 전체적인 벡터 코드 품질이 개선되었습니다.  
  
-   **스칼라 최적화 개선** 비트 테스트 작업의 코드가 보다 효율적으로 생성되고, 제어 흐름 병합 및 최적화 기능\(loop\-if 전환\)과 기타 스칼라 최적화 기능\(예: std::min 및 std::max를 위한 효율적인 코드 생성\)이 제공됩니다.  
  
-   **PGO\(프로필 기반 최적화\)** PGO의 기능이 상당히 향상되었습니다. 여기에는 개선된 참조 집합, 보다 효율적인 데이터 레이아웃 기능 및 이전에 결정한 인라인, 속도와 크기 간의 균형 및 레이아웃 설정을 다시 사용하는 기능이  포함됩니다.  
  
##  <a name="BK_IDE"></a> 생산성, 디버깅 및 진단  
  
###  <a name="BK_SingleFileIntelliSense"></a> 단일 파일 IntelliSense  
 이제 프로젝트 파일을 열지 않고도 편집기에서 단일 소스 코드 파일을 열 때 IntelliSense를 사용할 수 있습니다.  
  
###  <a name="BK_Refactoring"></a> 리팩터링  
 다음 기능을 통해 C\+\+에 대한 리팩터링 지원이 추가되었습니다.  
  
-   **기호 이름 변경** 발견되는 모든 기호를 새 이름으로 변경합니다.  
  
-   **함수 추출** 선택한 코드를 자체 함수로 이동합니다.  이 리팩터링은 Visual Studio 갤러리에서 Visual Studio 확장으로 제공됩니다.  
  
-   **순수 가상 함수 구현** 클래스나 구조체에 의해 상속되는 순수 가상 함수에 대한 함수 정의를 생성합니다.  다중 상속 및 재귀 상속이 지원됩니다.  이 리팩터링을 상속하는 클래스 정의에서 활성화하여 상속되는 모든 순수 가상 함수를 구현하거나, 기본 클래스 지정자에서 활성화하여 해당 기본 클래스에서만 순수 가상 함수를 구현할 수 있습니다.  
  
-   **선언 또는 정의 만들기** 기존 정의에서 선언을 생성하거나 기존 선언에서 기본 정의를 생성합니다.  기존 선언 또는 정의나 전구 모양 표시기에서 이 리팩터링에 액세스합니다.  
  
-   **이동 함수 정의** 소스 코드와 헤더 파일 간에 함수 본문을 이동합니다.  함수의 서명에서 이 리팩터링을 활성화합니다.  
  
-   **원시 문자열 리터럴로 변환** 이스케이프 시퀀스가 포함된 문자열을 원시 문자열 리터럴로 변환합니다.  지원되는 이스케이프 시퀀스는 \\\\\(백슬래시\), \\n\(줄 바꿈\), \\t\(탭\), \\'\(작은따옴표\), \\"\(큰따옴표\) 및 \\?\(물음표\)입니다.  설정합니다.  문자열 내에서 아무 곳이나 마우스 오른쪽 단추로 클릭하여 이 기능을 활성화합니다.  
  
 파일에서 찾기가 후속 결과를 이전 결과에 추가할 수 있도록 하여 개선되었습니다. 누적된 결과는 삭제할 수 있습니다.  
  
 **IntelliSense 가독성 개선** 복잡한 템플릿 인스턴스화 및 형식 정의가 보다 쉽게 읽을 수 있도록 매개 변수 도움말 및 요약 정보에서 간소화되었습니다.  
  
###  <a name="BK_PDB"></a> 프로그램 데이터베이스 향상 기능  
  
-   솔루션 검사 속도\(특히 큰 솔루션의 경우\)가 개선되었습니다.  
  
-   새 솔루션을 처음으로 여는 초기 솔루션 검사를 제외하면 솔루션 검사 중에 정의로 이동 등의 작업이 더 이상 차단되지 않습니다.  
  
##  <a name="BK_Diagnostics"></a> 진단  
  
1.  **디버거 시각화** 손쉬운 관리 및 소스 제어 통합을 위해 Natvis 디버거 시각화를 Visual Studio 프로젝트에 추가할 수 있습니다.  디버깅 세션 중에 Natvis 파일을 편집 및 저장할 수 있으며, 디버거가 자동으로 변경 내용을 수집합니다.  자세한 내용은 이 [블로그 게시물](http://blogs.msdn.com/b/vcblog/archive/2014/06/12/project-support-for-natvis.aspx)\(영문\)을 참조하세요.  
  
2.  **기본 메모리 진단**  
  
    1.  **메모리 진단 세션**\(Ctrl\+Alt\+F2\)을 사용하면 디버깅 세션 중에 네이티브 응용 프로그램의 라이브 메모리 사용을 모니터링할 수 있습니다.  
  
    2.  **메모리 스냅숏**에서는 응용 프로그램 힙 콘텐츠의 임시 이미지를 캡처합니다.  두 메모리 스냅숏을 비교하여 힙 상태의 차이를 검사할 수 있습니다.  응용 프로그램을 중지한 후 각 인스턴스에 대해 개체 형식, 인스턴스 값 및 할당 호출 스택을 확인할 수 있습니다.  각 스냅숏에 대한 스택 프레임별 호출 트리를 표시합니다.  
  
3.  **교착 상태 감지 및 복구 기능 개선** 조사식 및 직접 실행 창에서 C\+\+ 함수를 호출할 때 개선된 기능을 사용할 수 있습니다.  
  
4.  **컴파일러 진단 개선** 컴파일러에서 의심스러운 코드에 대한 향상된 경고를 제공합니다.  숨겨진 변수와 일치하지 않는 printf 형식 문자열 등에 대한 새로운 경고가 추가되었습니다.  기존 경고 메시지도 더 명확해졌습니다.  
  
5.  **\/Wv 플래그** \/Wv:XX.YY.ZZZZ 플래그를 사용하면 특정 컴파일러 버전 XX.YY.ZZZZ 이후 도입된 경고를 사용하지 않도록 설정할 수 있습니다.  \/Wv 플래그를 통해 지정하는 경고 이외의 경고도 특정하게 사용하지 않도록 설정할 수 있습니다.  
  
6.  **최적화된 코드 디버깅 지원 개선** \/Zi, \/Zo 또는 \/Z7 플래그를 사용하여 코드를 디버그할 수 있습니다.  
  
##  <a name="BK_Win10"></a> Windows 10 대상  
 Visual Studio는 이제 C\+\+에서 Windows 10을 대상으로 하도록 지원합니다.  유니버설 Windows 앱 개발을 위한 새 프로젝트 템플릿이 데스크톱 컴퓨터, 휴대폰, 태블릿, HoloLens 및 기타 장치와 같은 Windows 10 장치를 대상으로 할 수 있도록 지원합니다.  자세한 내용은 [Windows 10에서 "hello world" 앱 만들기](https://msdn.microsoft.com/en-us/library/windows/apps/dn996906.aspx)를 참조하세요.  
  
##  <a name="BK_GraphicsDiagnostics"></a> 그래픽 진단  
 다음 기능을 통해 그래픽 진단이 개선되었습니다.  
  
-   **DirectX12에 대한 그래픽 진단 지원.** 이제 Visual Studio 그래픽 진단 도구에서 DirectX12 응용 프로그램의 렌더링 문제 디버그를 지원합니다.  
  
-   **연속 캡처** 캡처 한 번에 연속 프레임을 30개까지 캡처할 수 있습니다.  
  
-   **프로그래밍 방식 캡처** 프레임 캡처를 프로그래밍 방식으로 시작할 수 있습니다.  Present를 호출하지 않는 프로그램에서 계산 셰이더를 디버그하는 경우나 렌더링 문제를 수동으로 캡처하기는 어렵지만 런타임에 앱 상태에서 프로그래밍 방식으로 예측할 수 있는 경우 프로그래밍 방식 캡처가 특히 유용합니다.  
  
-   **향상된 그래픽 이벤트 목록** 캡처된 이벤트와 해당 상태를 그리기 호출로 구성된 계층 구조에 표시하는 새로운 그리기 호출 뷰가 추가되었습니다.   그리기 호출을 확장하여 그리기 호출 시 현재 상태였던 장치 상태를 표시할 수 있으며, 각 상태 종류를 추가로 확장하여 해당 값을 설정하는 이벤트를 표시할 수 있습니다.  
  
-   **Windows Phone 8.1 지원** 이제 그래픽 진단에서 휴대폰 에뮬레이터 또는 테더링된 휴대폰의 Windows Phone 8.1 앱 디버깅을 완전하게 지원합니다.  
  
-   **그래픽 프레임 분석** 이 도구는 캡처된 프레임에 대한 성능 측정값을 수집합니다. 또한 미리 정의된 일련의 실험을 수행하므로 다양한 질감 기술을 적용할 때 성능에 어떤 영향을 주는지를 파악할 수 있습니다.  또한 프레임 분석은 하드웨어에서 성능 카운터를 수집합니다.  
  
-   **그래픽 분석 전용 UI** 그래픽 프레임 분석을 위한 전용 작업 공간인 Visual Studio 그래픽 분석기 창이 새롭게 제공됩니다.  
  
-   **셰이더 편집 및 적용** 앱을 다시 실행하지 않고도 캡처된 로그에서 셰이더 코드 변경의 영향을 확인할 수 있습니다.  
  
-   도구\-\>옵션\-\>그래픽 진단에서 캡처 옵션을 구성합니다.  
  
-   프레임 캡처 및 재생을 위한 명령줄 도구가 제공됩니다.  
  
 자세한 내용은 [그래픽 진단\(DirectX 그래픽 디버그\)](../Topic/Visual%20Studio%20Graphics%20Diagnostics.md)을 참조하세요.  
  
##  <a name="BK_GPUUsage"></a> 새로운 GPU 사용량 도구  
 Visual Studio 2015에서는 GPU 사용량 도구를 사용하여 DirectX 응용 프로그램의 GPU 사용량을 파악할 수 있습니다.  응용 프로그램을 라이브로 실행하는 동안 프레임 시간, 프레임 속도 및 GPU 사용률 그래프를 사용할 수 있습니다.  또한 이 도구는 자세한 GPU 사용량 데이터를 수집 및 분석하여 개별 DirectX 이벤트의 CPU 및 GPU 실행 시간에 대한 정보를 제공할 수 있으므로 CPU 또는 GPU가 성능 병목 현상의 원인인지를 확인하는 데 유용할 수 있습니다.  [GPU 사용량](../Topic/GPU%20Usage.md)을 참조하세요.  
  
##  <a name="BK_MFC"></a> MFC의 새로운 기능  
 이제 사용자가 대화 상자 크기를 변경할 때 컨트롤이 자동으로 크기를 조정하고 이동하는 방식을 지정할 수 있습니다.  자세한 내용은 [동적 레이아웃](../mfc/dynamic-layout.md)을 참조하세요.  
  
## 참고 항목  
 [Visual Studio 2015의 새로운 기능](../Topic/What's%20New%20in%20Visual%20Studio%202015.md)   
 [Visual C\+\+ 팀 블로그 \(영문\)](http://blogs.msdn.com/b/vcblog/)